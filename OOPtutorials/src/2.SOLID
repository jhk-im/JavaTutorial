https://limkydev.tistory.com/77

// SOLID 원칙
-> 자기 자신 클래스 안에 응집도는 내부적으로 높이고,
   타 클래스들 간 결합도는 낮추는
   High Cohesion - Loose Coupling 원칙을 객체 지향 관점에서 도입한 것
   모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈을 만들기 위함.
   재사용성을 높이고 수정을 최소화하여 유지보수가 용이하도록 함

1. SRP
-> Single Responsibility Principle 단일 책임 원칙
    "어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다." -로버트 C. 마틴
   즉, 클래스를 설계할 때 어플리케이션의 경계를 정하고,
   추상화를 통해 어플리케이션 경계안에서 필요한 속성과 메서드를 선택하여 설계해야한다.

   Person 이라는 클래스를 정의해보자.

   Person
   +name
   +tall
   +bloodType
   +caseHistory
   +developmentLanguage
   +career

   이 경우 개발 스펙을 검토하는 어플리케이션이 있다고 가정하자.
   개발 스팩을 검토하는 어플리케이션에선 사람이라는 클래스보다 지원자라는 클래스명이 더 어울린다.
   필요한 필드는 개발경력, 개발언어 정도이다.
   Developer
   +developmentLanguage
   +career

   이렇게 사람이라는 클래스에 모든 기능을 다 때려박기 보다는
   목적과 취지에 맞는 속성과 메서드로 구성해야 한다.
   즉, 관련된 책임만 주라는 것이다.

   극단적인 예시를 살펴보자

   Person
   +요리하다()
   +잠자다()
   +공부하다()
   +개발하다()
   +운동하다()
   +게임하다()

   위처럼 Person 은 다양한 행위를 한다.
   집이라면 상관 없겠지만 상황에 맞게 정리되었다고는 볼 수없다.
   상황이 회사라고 한다면 잠자다() 와 게임하다() 는 호출이 안되도록 조치를 취해야 할 것이다.
   즉, 상황에 맞는 속성과 메서드로 책임을 적게 할당하자는 것이다.

   [회사]
   Developer
   + 개발하다()

   하나의 클래스로만 한꺼번에 구현하려 하지 말고, 역할에 맞게 클래스를 설계해야 한다.
   더 나아가 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크를 단일 책임을 주고,
   독립적으로 모듈화 시키는 것이 바로 SRP 단일책임원칙이다.

2. OCP
-> Open Closed Principle 개방 폐쇄 원칙
    "소프트웨어 엔티티(클래스,모듈,함수 등)는 확장에 대해서는 열려있어야 하지만
    변경에 대해서는 닫혀있어야 한다."  - 로버트 C. 마틴

   만약 A 드론과 연동하는 프로그램을 개발한다고 생각해보자.
   하지만 새롭게 출시한 B 드론이 더 가격이 싸고 성능도 좋다.
   A 드론과 연동한 프로그램은 수정이 필요하다.
   이럴 경우 프로그램은 어느 회사의 제품 드론을 연동하던
   프로그램의 수정을 최소화 하면서 확장적으로 다른 제품의 드론과 연동할 수 있어야 한다.

   A사 드론
   A 방식 날기()
   A 방식 착지()
   A 방식 조작()

   B사 드론
   B 방식 날기()
   B 방식 착지()
   B 방식 조작()

   위처럼 직접적으로 각 사의 제품 클래스의 메소드를 호출하도록 설계했다면,
   확장적이지 못할 뿐더러 많은 수정이 발생되어 유지 보수가 어려워 진다.

   OCP(개방 폐쇄 원칙) 으로 수정

   interface 드론
   날기()
   착지()
   조작()

   A사 드론 / 날기(), 착지(), 조작()
   B사 드론 / 날기(), 착지(), 조작()

   각 제품의 드론 클래스는 드론 interface 를 implements 하고
   추상메서드인 날기(), 착지(), 조작() 메서드를 오버라이딩 하여
   자기 입맛에 맞게 메서드를 재정의하면 된다.

   확장적이면서 어플리케이션 입장에서 수정은 폐쇄적인 것을 OCP 개방 폐쇄 원칙이라 한다.

3. LSP
-> Liskov Substitution Principle 리스코프 치환 원칙
    "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴

   LSP 는 인터페이스와 클래스 관계,
   상위 클래스와 하위 클래스 관계를 얼마나 논리적으로 설계했느냐가 관건이다.
   상위 클래스와 하위 클래스는 말그대로 상속 관계가 성립되었다는 뜻이다.
   단순히 아버지와 아들과 같이 계층적인 구조가 아닌 분류 이다.
   상속은 확장이다.
   아버지와 아들 // 아들은 아버지의 한 종류이다 X
   포유류와 고래 // 고래는 포유류의 한 종류이다 O

   인터페이스 이름을 잘 보면 통상적으로 ~able 을 붙인다.
   Runnable : ~ 실행할 수 있는 ..
   class Person implements Runnable ()
   -> Person 은 무언가를 실행할 수 있다.

   인터페이스는 위처럼 able 을 붙여 네이밍하고
   implements 한 구현 클래스는 인터페이스가 가지고 있는 기능을 할 수 있다는 것으로 생각하자.

   LSP 는 하위 클래스가 상위 클래스 역할을 대신할 때 논리적으로 맞아 떨어져야한다.
   Father kim = new 아들();
   -> 아들 kim 이 태어나 아버지의 행위를 한다? 어색하다. -> LSP 위배
   포유류 블루  = new 고래();
   -> 고래 블루 는 포유류 행위를 한다? 어색하지 않다.

   객체 지향은 인간이 실세계를 보면서 느끼고 논리적으로 이해한 것과 똑같이 프로그래밍하는 게 목적이다.
   논리적으로 맞아 떨여져야한다.


4. ISP
-> Interface Segregation Principle 인터페이스 분리 법칙
    "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다." - 로버트 C. 마틴
   ISP 는 SRP 와 같은 원인에 대한 다른 해결책을 제시하는 것이다.
   ISP 는 해당 클래스를 그대로 두는 상태에서
   인터페이스 최소주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링 한다고 생각하면 쉽다.

   Person
   개발하기()
   요리하기()
   잠자기()
   게임하기()

   만약 개발자 역할만 해야하는 상황에서는
   요리하기(), 잠자기(), 게임하기() 는 필요없게 된다.
   이럴경우 ISP 를 적용하여 각 역할에 맞는 메서드만 제공하도록 한다.

   Developer implement Person
   개발하기()

   각 상황에 맞게 인터페이스에서 제공해주는 메서드만 제공받아 사용할 수 있도록 한 것이다.
   인터페이스 최소 주의와 함께 상위 클래스는 풍성하고 인터페이스는 적을 수록 좋다는 개념이 있다.


5. DIP
-> Dependency Inversion Principle 의존역전법칙
    "자주 변경되는 구체(Concrete) 클래스에 의존하지 마라" - 로버트 C. 마틴

  DSP 는 자신보다 변하기 쉬운것에 의존하지 말라는 ㄸ쓰이다.
  구체적으로 추상클래스 또는 상위클래스는
  구체적인 구현클래스 또는 하위클래스에게 의존적이면 안된다.
  왜냐하면 구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감하다.
  DIP 를 무시한 체 설계한다면 ,
  구체화된 클래스가 수정될 때마다 상위클래스나 추상클래스가 변화해야하는데
  연관되어있는 클래스들을 모두 수정해야만 한다.
  예를 들어보자

  벤츠 -> 스노우타이어

  벤츠는 스노우타이어를 장착하고 있다.
  하지만 스노우타이어는 계절에 영향을 받기 때문에 겨울 폭설이 오는경우가 아니면,
  다른 타이어로 교체하는 것이 맞다.
  벤츠라는 클래스가 자신보다 더 변화에 민감한 스노우타이어를 의존하고 있는 것이다.
  다음과 같이 일방적인 방향을 역전시켜보자.

  벤츠 -> 인터페이스 타이어  <- 스노우 , 일반, 광폭

  자신보다 변하기 쉬운것에 의존하던 것을 추상화 된 인터페이스나 상위 클래스를 두어
  변하기 쉬운 것의 변화에 영향을 받지 않게 의존 방향을 역전 시켰다.
  즉, 벤츠 클래스는 타이어 인터페이스에 의존하면서
  직접적으로 스노우, 일반, 광폭 타이어와 의존하는 것을 피했다.
  스노우, 일반, 광폭 타이어는 타이어 인터페이스를 의존해야 한다.

  *상위로 갈 수록 더 추상적이고 변화에 민감하지 않으며 수정 가능성이 낮아진다.

  OCP 개발폐쇄 원칙을 설명할때와 비슷한 설계구조이다.
  하나의 설계원칙 안에 다른 설계원칙이 녹아져 있는 경우가 많다.

  * 설계를 잘 해야 프로그램 유지 보수 측면에서 굉장히 용이하고
    개발 시간과 비용을 절감할 수 있다.

