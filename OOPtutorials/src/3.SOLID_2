https://gmlwjd9405.github.io/2018/07/05/oop-solid.html

// OOP 설계 원칙을 이해한다.
// SRP 단일책임 원칙을 이해한다.
// OCP 개방-폐쇄 원칙을 이해한다.
// LSP 리스코프 치환 원칙을 이해한다.
// ISP 인스턴트 분리 원칙을 이해한다.
// DIP 의존 역전 원칙을 이해한다.

*설계원칙 학습의 이유
    -> 예측하지 못한 변경사항이 발생하더라도 유연하고 확장성이 있도록 시스템 구조를 설계하기 위해

*좋은 설계란?
    -> 시스템에 새로운 요구사항이나 변경이 있을 때 가능한 영향 받는 부분을 줄이도록 하는 것

1. 단일책임 원칙 SRP
객체는 단 하나의 책임만 져야한다.
    책임?
        -> 해야하는 것, 할 수 있는 것, 해야하는 것을 잘 할수 잇는 것
        -> 어떤 객체보다도 책임에 대하여 작업을 잘 할 수 있는 객체에 책임을 할당해야 한다.
    책임분리
        -> 한 클래스에 단 하나의 책임만 수행하도록 해 변경 사유가 될 수 있는 것을 하나로 만들어야 한다.
            -> 책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다.

    산탄총 수술
        -> 하나의 책임이 여러 개의 클래스들로 분산되어 있는 경우에도 단일 책임 원칙에 입각해 설계를 변경해야하는 경우도 있다.
            -> 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능
            -> 횡단 관심에 속하는 기능은 대부분 시스템 핵심기능(하나의 책임) 안에 포함되는 부가기능(여러개의 분리된 클래스)이다.
        -> 부가 기능을 별개의 클래스로 분리해 책임을 담당하게 한다.
            -> 즉, 여러 곳에 흩어진 공통 책임을 한 곳에 모으면서 응집도를 높인다.
            -> 하지만 이런 독립 클래스를 구현하더라도 구현된 기능들을 호출하고 사용하는 코드는
               해당 기능을 사용하는 코드 어딘가에 포함될 수밖에 없다.

    관심지향 프로그래밍(AOP)과 횡단 관심 문제
        -> 횡단 관심 문제(Cross Cutting Concern) 를 해결하는 방법?
            -> 관심지향 프로그래밍 기법 (AOP, Aspect Oriented Programming)
        -> AOP 란?
            -> 횡단 관심을 수행하는 코드는 aspect 라는 특별한 객체로 모듈화하고
               weaving 이라는 작업을 통해 모듈화한 코드를 핵심 기능에 끼워넣을 수 있다.
            -> 이를 통해 기존의 코드를 전혀 변경하지 않고 시스템 핵심 기능에서 필요한 부가 기능을 효과적으로 이용할 수 있다.
            -> 만약 횡단 관심에 변경이 생긴다면 해당 aspect 만 수정하면 된다.
        -> AOP 관련용어
            -> JoinPoint : 애플리케이션 실행 중의 특정한 지점
            -> Advice : 특정 JoinPoint 에 실행하는 코드
            -> PointCut : 여러 JoinPoint 의 집합체로, 언제 Advice 를 실행할지 정의할 때 사용
            -> Aspect : 애플리케이션이 가져야 할 로직과 그것을 실행해야 하는 지점을 정의한 것
            -> Weaving : 애플리케이션 코드의 해당 지점에 Aspect 를 실제로 주입하는 과정


2. 개방-폐쇄의 원칙 OCP
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있또록 설꼐까 되어야 한다.
    -> 설계의 기본 (의존 역전 원칙(DIP)과 밀접)
    -> OCP 를 만족하는 설계

        외부 SomeClient ---> 부모클래스 (슈퍼클래스) printStudent <interface>
        printStudent -> Student -> Student DAO
        printStudent <- 성적표 / 도사관 대여 명부 / 출석부

        인터페이스 (변하지 않는 것) 에서 구체적인 출력매체 (변하는 것) 를 갭슐화 해 처리하도록 해야한다.

    -> OCP 설계시 가장 중요한 점
        -> 무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분해야 한다는 점이다.
        -> 변해야 하는 것은 쉽게 변할 수 있게 하고,
        -> 변하지 않아야 할 것은 변하는 것에 영향을 받지 않게 해야 한다.

    -> 클래스를 변경하지 않고 대상 클래스의 환경을 변경할 수 있는 설계가 되어야 한다.
        -> 단위 테스트를 수행할 때 매우 중요

3. 리스코프 치환 원칙 LSP
일반화 관계에 대한 이야기며,
자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.
    -> LSP 는 부모 클래스와 자식 클래스 사이의 행위가 일관성 있어햐 한다는 의미이다.
        -> 즉, 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스로 대체해도
           프로그램 의미가 변화되지 않는다.
    -> 일반화 관계
        -> is a kind of 관계
        -> 원숭이 is a kind of 포유류
        -> 포유류(부모클래스), 원숭이 (자식클래스)
    -> LSP 를 만족시키는 간단한 방법은 재정의하지 않는 것
        -> 즉, 부모클래스에서 상속받은 메서드들이 자식 클래스에 오버라이드, 즉 재정의 되지 않도록 하면 된다.
        -> '자식 클래스가 부모 클래스의 책임을 무시하거나 재정의 하지 않고 확장만 수행한다'

4. 인터페이스 분리 원칙 ISP
인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.
    -> 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다.
    -> 단일 책임 원칙(SRP)과 밀접하다.
    -> 복합기 클래스 다이어그램

        복합기
        +copy()
        +fax()
        +print()
        <- 프린터, 복사, 팩스  클라이언트

        -> 복합기 기능을 제공하는 클래스는 매우 비대해질 가능성이 크다.
        -> 하지만 복합기의 모든 기능을 클라이언트가 동시에 사용하는 경우는 거의 없다.
        -> 팩스 기능의 변경으로 인해 프린터 기능만 이용하는 클라이언트가 영향받을 수 있다.
        -> 이렇게 클라이언트와 무관하게 발생한 변화로 클라이언트 자신이 영향을 받지 않으려면
           범용의 인터페이스 보다는 클라이언트에 특화된 인터페이스를 사용해야한다.

         인터페이스 프린터
         +print() <----  프린터 클라이언트

         인터페이스 복사기
         +copy() <---- 복사 클라이언트

         인터페이스 팩스
         +fax() <---- 팩스 클라이언트

         -> 복합기를 사용하는 객체들마다 자신이 관심을 갖는 메서드들만 있는 인터페이스를 제공받도록 설계함
         -> 인터페이스가 일종의 방화벽 역할을 수행
         -> 클라이언트는 자신이 사용하지 않는 메서드에 생긴 변화로 인한 영향을 받지 않게 된다.

    -> SRP 와 ISP 의 관계
        -> 어떤 클래스가 여러 책임을 수행하게 되면 방대한 메서드를 가진 비대한 클래스가 될 가능성이 커진다.
            -> 이렇게 비대한 클래스를 단일 책임을 갖는 여러 클래스로 분할하면 SRP 를 만족한다.
            -> 또한 각자의 인터페이스를 제공한다면 ISP 를 만족할 수 있다.
        -> 그렇다면 ISP 는 SRP 를 만족하면 성립되는가?
            -> 반드시 그렇다고 볼 수 없다.

            인터페이스 게시판
            +글쓰기()
            +읽기()
            +수정()
            +삭제()
            SRP 만족 -> 게시판 클래스는 게시판과 관련된 책임을 수행한다.

            일반사용자
            +글쓰기()
            +읽기()
            +수정()
            -삭제()
            ISP 만족 X -> 일반사용자는 삭제 기능을 사용할 수 없다.
            즉, 모든 메소드가 들어있는 인터페이스가 클라이언트에 상관없이 사용되었다.


5. 의존 역전 원칙 DIP
의존 관계를 맺을 때 변화히기 쉬운 것
또는 자주 변화하는 것보다는 변화하기 어려운것,
거의 변화가 없는 것에 의존하라는 것이다.
    -> 객체 사이에 서로 도움을 주고 받으면 의존 관계가 발생한다.
    -> DIP 가 의존관계의 가이드 라인에 해당한다.
        -> 클래스간 의존관계?
            -> 한 클래스가 어떤 기능을 수행하려고 할 때, 다른 클래스의 서비스가 필요한 경우
    -> OCP 가 되려면 기본적으로 DIP 가 만족되어야 한다.
    -> 변화하기 쉬운 것과 변화하기 어려운것의 구분
        -> 변화하기 어려운 것 : 정책, 전략
        -> 변화하기 쉬운 것 : 구체적인 방식, 사물
        -> DIP 예시

           외부세계  [아이] 클래스
           ->  부모클래스 (슈퍼클래스)   장난감 <<abstract>>
           <-  자식 클래스 (서브클래스) 로봇, 모형자동차, 레고 [캡슐화 (은닉)]

           ->객체지향 관점에서 변하기 어려운 추상적인 것들을 표현하는 수단
                -> 추상클래스 abstract
                -> 인터페이스 interface

        -> DIP 만족
            -> 어던 클래스가 도움을 받을 때 구체적인 클래스보다는
                인터페이스나 추상클래스와 의존 관계를 맺도록 설계해야 한다.

        -> DIP 를 만족하는 설계는 변화에 유연한 시스템이 된다.
            -> 의존성 주입 이라는 기술로 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있다.
                ->의존성 주입?
                    -> 클래스 외부에서 의존되는 것을 대상 객체의 인스턴스 변수에 주입하는 기술
            ->Hollywood principle?
                -> Don't call us, we'll call you
                -> we 프레임 워크 / you 구현 모듈, 필요 객체

            -> 예시
            public class kid {
            private Toy toy;
            public void setToy(Toy toy){this.toy = toy;}
            public void play(){System.out.println(toy.toString()); }
            }
            public class Robot extends Toy {
            public String toString() { return "Robot"; }
            }
            public class Lego extends Toy {
            public String toString() { return "Lego"; }
            }

            public class Main {
            public static void main(String[] args) {
                Kid k = kid();
                // 1. 아이가 로봇을 가지고 놀때
                Toy t = new Robot();
                // 2. 레고를 가지고 놀 때
                Toy t = new Lego();
                k.setToy(t);
                k.play();
            }
            }

            -> 아이가 마음이 바뀌어 다른 어떤 장난감을 가지고 놀더라도
               코드에 전혀 영향을 받지 않고도 장난감을 바꿀 수 있다.